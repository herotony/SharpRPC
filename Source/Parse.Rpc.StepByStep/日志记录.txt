2014-12-09

15:39 完成Topology的相关功能：读取rpc服务配置，rpc服务配置支持SingleHost[单个端口]和Random[多个端口，随机取一个]的服务配置。
	  ServiceEndPoint格式：tcp://10.9.60.61:8080 or tcp://domain_name:9090
	  rpc配置文件中固定每行的格式为：ServiceName TopologyType(single or random) tcp://domain_name:9090,tcp://domain_name:9191

2014-12-10

	  MethodDescriptionBuilder是根据反射Type提取MethodInfo动态创建方法的核心！

	  MethodDescription [由MethodRemotingType enum,MethodParameterWay enum,MethodParameterDescription,GenericParameterDescription支撑其方法描述功能，用于生成相关方法]

	  今天搞定了ServiceDescriptionBuilder，可以完整获取一个接口的描述信息用于后续的动态生成dynamic assembly!

tip：Linq的Select是专门针对各种集合的每个元素进行【委托方法】的额外处理后返回一个处理后的结果集。

	static void Main()
    {
		// An input data array.
		string[] array = { "cat", "dog", "mouse" };

		// Apply a transformation lambda expression to each element.
		// ... The Select method changes each element in the result.
		var result = array.Select(element => element.ToUpper());

		// Display the result.
		foreach (string value in result)
		{
	    	Console.WriteLine(value);
		}
    }
		
2014-12-11

		开始CodecContainer剖析，基本就是靠TypeBuilder来创建instance和其内部的处理！进入关键部分了...

		还是从ProxyFactory切入：

			1、设定new一个ServiceDescriptionBuilder用以剖析某个接口，亦即ProxyContainer中传入的泛型接口T
			2、设定new一个codecContainer传入最终创建的动态Assembly内进行输入数据的提取？
			3、AppDomain.CurrentDomain来DefineDynamicAssembly->assemblyBuilder.DefineDynamicModule->moduleBuilder.DefineType->TypeBuilder负责fieldCache和classContext的创建

				fieldCache实际就是ProxyClassFieldCache亦即创建几个proxy instance用到的内部字段：methodCallProcessor,scope,timeoutSettings,codecContainer,(manualCodecFields干嘛的还不清楚)
				classContext实际就是通过之前的TypeBuilder创建给DynamicAssembly的module的类型和相关方法以及类型的“构造函数”

				typeBuilder.DefineMethod->methodBuilder.GetILGenerator()->iL

			4、CreateMethod、CreateConstructor
				
				 ProxyMethodParameterCodec：用于动态生成Method参数，重点看如何处理，该类负责为每个参数设定相应的处理引擎(如何提取参数值，如何计算大小，如何转换为二进制数组)

				 ILGenerator is used to generate method bodies for methods and constructors in dynamic assemblies.

				 注意这里强调是"method bodies"，即method和其相关的输入参数在methodBuilder中定义，但方法体中的执行代码采用iL生成。

				 OpCode：struct,用于描述Intermediate Language指令
				 OpCodes：定义了所有的OpCode.
				 ILGenerator.Emit(OpCode,...):将设定的指令OpCode和相关的...其他参数写入dynamic assemblies的IL流中。

				 EmitCalculateSize计算获取每个输入参数的字节大小
				 然后，再根据该大小初始化一个大的字节数组
				 EmitEncode,将各个参数转化为相应的字节数据写入该数组(如果序列化应该是在此引入序列化引擎或者计算输入参数前)

2014-12-12

		如果有时间，重点剖析ProxyFactory的CreateMethod方法中如何生成处理输入参数的执行代码
			ProxyMethodEmittingContext

		下周继续吧，今儿就先这样吧，唉...

		不再纠缠方法类型支持了，一律采用"byte[] methodname(byte[] input)"，只是在其外封装一层T methodnamewrapper(T1);即可。
		后续尽快模拟相关代码其余架构，不再纠结Emit处理引用类型的问题了。继续...本周必须搞定嵌入tcp通讯架构即可。

2014-12-16

				之前的methodBuilder定义了创建方法的名称，参数、返回参数类型等外壳信息，然后从methodBuilder的ILGenerator开始
				真正设定方法的执行代码逻辑，即如下中的il...

		        //用于封装传给远端服务器的请求参数，统一打包到byte[]中。
		        var requestDataArrayVar = il.DeclareLocal(typeof(byte[]));                      // byte[] dataArray

		        bool haveSizeOnStack = false;
                foreach (var codec in genericTypeParameterCodecs)
                {
                    codec.EmitCalculateSize(emittingContext);                               // stack_0 += CalculateSize(T_i)
                    EmitAddIf(il, ref haveSizeOnStack);
                }

                foreach (var parameter in requestParametersCodecs)
                {
                    parameter.EmitCalculateSize(emittingContext);                           // stack_0 += CalculateSize(arg_i)    
                    EmitAddIf(il, ref haveSizeOnStack);
                }

                //stack_0参数是byte大小的确定依据，是否代表了具体的参数具体数据大小已定？
                //data = dataPointer实际是将新创建的byte[]赋予emittingContext的DataPointer供后续写入真实参数数据
                //所以关键的两个foreach codec才是真正如何编码或者要额外可能序列化地方，唉...
                il.Newarr(typeof(byte));                                                    // dataArray = new byte[stack_0]
                il.Stloc(requestDataArrayVar);
                var pinnedVar = il.PinArray(typeof(byte), requestDataArrayVar);             // var pinned dataPointer = pin(dataArray)
                il.Ldloc(pinnedVar);                                                        // data = dataPointer
                il.Stloc(emittingContext.DataPointerVar);


                //最最关键的两行EmitEncode!!!!!!
                //EmitEncode是关键吗？这里的codec目前看来都是Proxy用的IndirectCodec.cs
                foreach (var codec in genericTypeParameterCodecs)
                    codec.EmitEncode(emittingContext);                                      // Encode(T_i, data)

                foreach (var codec in requestParametersCodecs)
                    codec.EmitEncode(emittingContext); 


                *********EmitCalculateSize*********
				根据type载入相应的ManualCodec,然后提取参数值？然后再用ManualCodecMethods.CalculateSize计算具体的数据大小
				这个是明天要搞定的关键点！即ManualCodec相关的代码！

				ProxyMethodEmittingContext->ProxyClassFieldCache->GetOrCreateManualCodec->typeBuilder.DefineType[typeof(IManualCodec<>).MakeGenericType(type)]从而获取ManualCode类型！

				ProxyMethodParameterCodec的Action<MyILGenerator>设定了提取当前方法参数值的方式!自测Ldarg_0和Ldobj【Ldobj貌似是只针对ref out标明的值类型参数拷贝到堆栈上，而引用类型参数呢？】，分别提取ref,out和其他方式的对象参数的值。


