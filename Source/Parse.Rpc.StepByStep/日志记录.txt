2014-12-09

15:39 完成Topology的相关功能：读取rpc服务配置，rpc服务配置支持SingleHost[单个端口]和Random[多个端口，随机取一个]的服务配置。
	  ServiceEndPoint格式：tcp://10.9.60.61:8080 or tcp://domain_name:9090
	  rpc配置文件中固定每行的格式为：ServiceName TopologyType(single or random) tcp://domain_name:9090,tcp://domain_name:9191

2014-12-10

	  MethodDescriptionBuilder是根据反射Type提取MethodInfo动态创建方法的核心！

	  MethodDescription [由MethodRemotingType enum,MethodParameterWay enum,MethodParameterDescription,GenericParameterDescription支撑其方法描述功能，用于生成相关方法]

	  今天搞定了ServiceDescriptionBuilder，可以完整获取一个接口的描述信息用于后续的动态生成dynamic assembly!

tip：Linq的Select是专门针对各种集合的每个元素进行【委托方法】的额外处理后返回一个处理后的结果集。

	static void Main()
    {
		// An input data array.
		string[] array = { "cat", "dog", "mouse" };

		// Apply a transformation lambda expression to each element.
		// ... The Select method changes each element in the result.
		var result = array.Select(element => element.ToUpper());

		// Display the result.
		foreach (string value in result)
		{
	    	Console.WriteLine(value);
		}
    }
		
2014-12-11

		开始CodecContainer剖析，基本就是靠TypeBuilder来创建instance和其内部的处理！进入关键部分了...

		还是从ProxyFactory切入：

			1、设定new一个ServiceDescriptionBuilder用以剖析某个接口，亦即ProxyContainer中传入的泛型接口T
			2、设定new一个codecContainer传入最终创建的动态Assembly内进行输入数据的提取？
			3、AppDomain.CurrentDomain来DefineDynamicAssembly->assemblyBuilder.DefineDynamicModule->moduleBuilder.DefineType->TypeBuilder负责fieldCache和classContext的创建

				fieldCache实际就是ProxyClassFieldCache亦即创建几个proxy instance用到的内部字段：methodCallProcessor,scope,timeoutSettings,codecContainer,(manualCodecFields干嘛的还不清楚)
				classContext实际就是通过之前的TypeBuilder创建给DynamicAssembly的module的类型和相关方法以及类型的“构造函数”

				typeBuilder.DefineMethod->methodBuilder.GetILGenerator()->iL

			4、CreateMethod、CreateConstructor
				
				 ProxyMethodParameterCodec：用于动态生成Method参数，重点看如何处理，该类负责为每个参数设定相应的处理引擎(如何提取参数值，如何计算大小，如何转换为二进制数组)

				 ILGenerator is used to generate method bodies for methods and constructors in dynamic assemblies.

				 注意这里强调是"method bodies"，即method和其相关的输入参数在methodBuilder中定义，但方法体中的执行代码采用iL生成。

				 OpCode：struct,用于描述Intermediate Language指令
				 OpCodes：定义了所有的OpCode.
				 ILGenerator.Emit(OpCode,...):将设定的指令OpCode和相关的...其他参数写入dynamic assemblies的IL流中。

				 EmitCalculateSize计算获取每个输入参数的字节大小
				 然后，再根据该大小初始化一个大的字节数组
				 EmitEncode,将各个参数转化为相应的字节数据写入该数组(如果序列化应该是在此引入序列化引擎或者计算输入参数前)

2014-12-12

		如果有时间，重点剖析ProxyFactory的CreateMethod方法中如何生成处理输入参数的执行代码
			ProxyMethodEmittingContext

		下周继续吧，今儿就先这样吧，唉...

		不再纠缠方法类型支持了，一律采用"byte[] methodname(byte[] input)"，只是在其外封装一层T methodnamewrapper(T1);即可。
		后续尽快模拟相关代码其余架构，不再纠结Emit处理引用类型的问题了。继续...本周必须搞定嵌入tcp通讯架构即可。

2014-12-16

				之前的methodBuilder定义了创建方法的名称，参数、返回参数类型等外壳信息，然后从methodBuilder的ILGenerator开始
				真正设定方法的执行代码逻辑，即如下中的il...

		        //用于封装传给远端服务器的请求参数，统一打包到byte[]中。
		        var requestDataArrayVar = il.DeclareLocal(typeof(byte[]));                      // byte[] dataArray

		        bool haveSizeOnStack = false;
                foreach (var codec in genericTypeParameterCodecs)
                {
                    codec.EmitCalculateSize(emittingContext);                               // stack_0 += CalculateSize(T_i)
                    EmitAddIf(il, ref haveSizeOnStack);
                }

                foreach (var parameter in requestParametersCodecs)
                {
                    parameter.EmitCalculateSize(emittingContext);                           // stack_0 += CalculateSize(arg_i)    
                    EmitAddIf(il, ref haveSizeOnStack);
                }

                //stack_0参数是byte大小的确定依据，是否代表了具体的参数具体数据大小已定？
                //data = dataPointer实际是将新创建的byte[]赋予emittingContext的DataPointer供后续写入真实参数数据
                //所以关键的两个foreach codec才是真正如何编码或者要额外可能序列化地方，唉...
                il.Newarr(typeof(byte));                                                    // dataArray = new byte[stack_0]
                il.Stloc(requestDataArrayVar);
                var pinnedVar = il.PinArray(typeof(byte), requestDataArrayVar);             // var pinned dataPointer = pin(dataArray)
                il.Ldloc(pinnedVar);                                                        // data = dataPointer
                il.Stloc(emittingContext.DataPointerVar);


                //最最关键的两行EmitEncode!!!!!!
                //EmitEncode是关键吗？这里的codec目前看来都是Proxy用的IndirectCodec.cs
                foreach (var codec in genericTypeParameterCodecs)
                    codec.EmitEncode(emittingContext);                                      // Encode(T_i, data)

                foreach (var codec in requestParametersCodecs)
                    codec.EmitEncode(emittingContext); 


                *********EmitCalculateSize*********
				根据type载入相应的ManualCodec,然后提取参数值？然后再用ManualCodecMethods.CalculateSize计算具体的数据大小
				这个是明天要搞定的关键点！即ManualCodec相关的代码！

				ProxyMethodEmittingContext->ProxyClassFieldCache->GetOrCreateManualCodec->typeBuilder.DefineType[typeof(IManualCodec<>).MakeGenericType(type)]从而获取ManualCode类型！

				ProxyMethodParameterCodec的Action<MyILGenerator>设定了提取当前方法参数值的方式!自测Ldarg_0和Ldobj【Ldobj貌似是只针对ref out标明的值类型参数拷贝到堆栈上，而引用类型参数呢？】，分别提取ref,out和其他方式的对象参数的值。

2014-12-18

				实现了个简单版的Emit，有助于后续理解相关的Proxy编写

				public interface IComplexEx{
			
					string GetStudent (Student st);
				}

				[Serializable]
				public class Student{

					public string Name{ get; set;}
					public int Age{ get; set;}
					public string Address{ get; set;}
					public bool Male{ get; set;}

					public override string ToString ()
					{
						return string.Format ("[Student: Name={0}, Age={1}, Address={2}, Male={3}]", Name, Age, Address, Male);
					}
				}

				private static void CreateClassForComplex(TypeBuilder typeBuilder){


						Type objType = Type.GetType("System.Object");
						ConstructorInfo objCtor = objType.GetConstructor(new Type[0]);

						var constructorBuilder = typeBuilder.DefineConstructor(
						MethodAttributes.Public, CallingConventions.Standard,new Type[0]);

						ILGenerator ilOfCtor = constructorBuilder.GetILGenerator();

						ilOfCtor.Emit(OpCodes.Ldarg_0);//this，当前实例引用，一般instance的类，ldarg_0就是this
						ilOfCtor.Emit(OpCodes.Call, objCtor);
						ilOfCtor.Emit (OpCodes.Ret);

						typeBuilder.AddInterfaceImplementation (typeof(IComplexEx));//必须加上这句才能代表实现相关接口...
						var methodInfo = typeof(Student).GetMethod ("ToString");
						var methodBuilder = typeBuilder.DefineMethod ("GetStudent", MethodAttributes.Public | MethodAttributes.Final | MethodAttributes.HideBySig |
											MethodAttributes.NewSlot | MethodAttributes.Virtual, CallingConventions.ExplicitThis | CallingConventions.HasThis,typeof(string), new Type[]{ typeof(Student) });

						ILGenerator ilOfmethod = methodBuilder.GetILGenerator ();

						ilOfmethod.Emit (OpCodes.Ldarg_1);//提取Student参数入栈
						ilOfmethod.Emit (OpCodes.Callvirt, methodInfo);//调用Student.ToString()并将结果入栈
						ilOfmethod.Emit (OpCodes.Ret);//返回栈中结果值

				}

				[Test]
				public void TestLdarg(){
		
					var appDomain = AppDomain.CurrentDomain;
					var assemblyBuilder = appDomain.DefineDynamicAssembly(new AssemblyName("rkProxies"), AssemblyBuilderAccess.RunAndSave);
					var moduleBuilder = assemblyBuilder.DefineDynamicModule("rkProxiesModule","rkProxies.dll");
					var typeBuilder = moduleBuilder.DefineType ("rkComplex", TypeAttributes.Public | TypeAttributes.Sealed | TypeAttributes.Class, typeof(object), new Type[]{typeof(IComplexEx)});

					//定义类及其相关类方法
					CreateClassForComplex (typeBuilder);

					try{

						var  type1 = typeBuilder.CreateType ();

						assemblyBuilder.SetEntryPoint(type1.GetMethod("GetStudent"));

						assemblyBuilder.Save("rkProxies.dll");

						Student st = new Student ();

						st.Address="北京";
						st.Age = 30;
						st.Male = false;
						st.Name = "H";

						object instance = Activator.CreateInstance(type1);

						IComplexEx complex = instance as IComplexEx;

						string result = complex.GetStudent(st);


					}catch(Exception e){

						string msg = e.Message;
					}
																								
					Assert.AreEqual (1, 1);
				}
2014-12-19

				非常好的教程：http://www.codeproject.com/Articles/121568/Dynamic-Type-Using-Reflection-Emit

				每个方法都需要TypeBuilder创建的MethodBuilder中获取ILGenerator来创建具体的方法体逻辑
				对于instance，Ldarg_0固定为this,则任何方法的第一个参数起始值为Ldarg_1
				OpCodes.st...开始的类似set,例如：stfld，设置某个实例字段值
				OpCodes.ld...开始的类似load，例如：ldloc_0，是载入局域变量值;ldfld，载入某个实例字段值

				***********split line***********

				A:创建构造类必须的相关类
					ProxyClassFieldCache：代理类缓存字段，根据Type确定[保存了TypeBuilder，其余的是四个关键的基于接口的字段定义且初始化时并不赋值：methodCallProcessor,scope,timeoutSettings,codecContainer，说白了后续的作用只是提供其“定义的接口类型”用于后续的Emit操作具体的instance]
					ProxyClassBuildingContext：代理类的创建类（TypeBuilder和FieldCache)

				B：针对具体的某个方法的每个参数进行Codec封装
					ProxyMethodParameterCodec：对方法的输入参数进行codec封装处理，都是固定用IndirectCodec，其关键点是后续传入的具体处理类IEmittingContext是何方神圣，目测是ProxyMethodEmittingContext
					ProxyMethodGenericArgumentCodec：对方法的泛型输入参数进行codec封装处理，都是固定用IndirectCodec，其关键点是后续传入的具体处理类IEmittingContext是何方神圣，目测是ProxyMethodEmittingContext

				C：
					ProxyMethodEmittingContext：唯一方法EmitLoadManualCodecFor为某个方法的某个参数类型(每中Type只创建一个cache字段)在ProxyClassFieldCache创建IManualCodec<Type>类型的对应字段codec_typename_randomnum而已，也仅仅是个字段定义！
					而后续的封装类ProxyMethodParameterCodec的EmitCalculateSize方法内部调用IndirectCodec的EmitCalculateSize方法内部最终调用ManualCodecMethods.CalculateSize方法计算参数数据大小，但这个ManualCodecMethods内部返回的是typeof(IManualCodec<>).MakeGenericType(type).GetMethodSmart("CalculateSize");的MethodInfo[GetMethodSmart是个扩展方法]，这个目前完全看不懂！
					后续的Encode,Decode都是这么得到MethodInfo然后调用的，关键是这只是接口定义，具体实现的instance怎么传入？



				再看ProxyFactory之CreateMethod

				就是看不明白CaculateSize,Encode,Decode是如何运作的，其余都过了...

				ProxyMethodParameterCodec.EmitCaculateSize中的emitload就得到了当前方法参数数据的具体大小后续只是继续追加封装类型IManualCodec<Ttype>类型定义的大小！oh yeah！搞定！ 

				IL.Ldarg(0);
                IL.Ldfld(fieldCache.GetOrCreateManualCodec(type));
                上面这个是将this.IManualCodec<Type>创建出来并Push入栈

                il => il.Ldarg(index);
                这个是将具体的type参数值Push入栈作为CaculateSize的输入参数待用

                //这里只是调用MethodInfo，当然只要一个简单的方法定义即可，亦即简单的：typeof(SomeType).GetMethod(methodName);
                //关键是真正的实例是通过ICodecContainer的instance传入并实现真正的调用。
                il.Callvirt(ManualCodecMethods.CaculateSize(type));

                这个是调用this.IManualCodec<Type>_Instance.CaculateSize(T Value)方法了，现在关键是看这个instance of IManual<Codec>是通过CodecContainer何时传入

                ManualCodecMethods.CalculateSize是如何运作的是下周的研究点,涉及ManualCodec,ManualCodecBase

2014-12-22

                CodeContainer是在RpcClient层传入

                CreateManualCodec入口点 -> GetEmittingCodecFor -> CreateCodec，根据具体的type获取具体的IEmittingCodec来处理具体类型的参数值

                而这些众多的IEmittingCodec实例则包含了具体如何Encode,Decode,CaculateSize的关键处理，本周好好都吃透了吧，尤其是对象类，集合类的处理!

2014-12-23

                RpcClient -> RpcClientComponentContainer -> proxyContainer -> T
                 				|                               |
                 				|                               | -> new  ProxySet<T>(processor,factory.CreateProxy<T>()) [这里的factory包含了CodecContainer!亦即由GetServiceProxyClassFactory()创建]
                 				|                 				                                               			                 				                                               				                  
                 				| -> GetIServiceProxyContainer
			 							|
			 							| -> GetOutgoingMethodCallProcessor() -> new OutgoingRequestProcessor(topology,requestSenderContainer,GetCodecContainer());
                         				|
                         				| -> GetServiceProxyClassFactory() -> new ProxyFactory(GetSeriveDescriptionBuilder(),GetCodecContainer())

                factory.CreateProxy<T> 
						|
						| -> var proxyClass = CreateProxyClass(typeof(T), typeof(T), null); 根据SeriveDescriptionBuilder创建动态Assembly Class[会缓存到ProxyContainer的ProxySet中]，然后生成Instance
						|
						| -> (T) Activator.CreateInstance(proxyClass, p, s, t, codecContainer); 传入 p: processor ; s: scope ; t: timeoutSetting ; codecContainer

				明天继续：只要顺藤摸瓜，找到caculateSize的执行路径即可，搞清到底是codecContainer动态生成的ManualCodec还是...


2014-12-24
				再看factory.CreateProxy<T>内部的CreateProxyClass方法：



				ProxyClassFieldCache：存储着创建的T类型的Proxy class的所有Field的声明定义而已，没有任何的具体实例化对象。实际是一种type对应一个FieldBuilder,类型固定为IManualCodec<type>，不会产生一个type多个FiledBuilder


				!!!****极其重要的地方****!!!

					所有ProxyClassFieldCache中定义的Field,包括各种IManualCodec<type>都是声明为FieldAttributes.InitOnly，亦即必须在构造函数时初始化且不能更改！即readonly型！

					相关初始化在【CreateConstructor】中完成！这是关键的关键，oh my God！ 总算彻底明确了IManualCodec<>的实例化处。

				!!!****极其重要的地方****!!!


				ProxyClassBuildingContext：关键就是负责保存创建Proxy Class所必须的TypeBuilder以及动态增加内部FiledBuilder定义的ProxyClassFieldCache

				ProxyClassBuildingContext则贯穿整个创建Proxy Class的所有过程:CreateMethod,CreateConstructor,即贯穿类中的所有方法

				//// CreateMethod \\\\：

				ProxyMethodEmittingContext则保存了具体创建方法处理逻辑的MyILGenerator和ProxyClassFieldCache，只贯穿具体的某一个方法，是具体的Emit执行者

				//关键的方法执行逻辑设定类
				ProxyMethodParameterCodec(MethodParameterDescription param)
					|
					| -> this.argIndex = param.Index+1;(因为index=0的为this)
					|    this.codec = new IndirectCodec(param.Type);(client端，固定为IndirectCodec)
					|    this.emitLoad = param.Way == MethodParameterWay.Val ? Loaders.Argument(argIndex) : Loaders.Argument(argIndex,param.Type);
					|                                                                   |
					|                                                                   | -> return il=>il.Ldarg(argIndex);//提取具体的参数值并Push到栈
					|
					| -> EmitCalculateSize(ProxyMethodEmittingContext ec);//为方法的每个参数计算其值所占字节空间大小
							|
							| -> indirectCodec.EmitCalculateSize(ec,this.emitLoad)
												|
												| -> ec.EmitLoadManualCodecFor(param.Type); {il.Ldarg(0);IL.Ldfld(fieldCache.GetOrCreateManualCodec(param.Type));} //??相当于(比如:type为string) IManualCode<string> this.codecFor_typename_number的实例对象地址压入栈。
												     il.Ldarg(argIndex);//提取参数并push入栈，将CaculateSize的参数压入栈，供后续的调用使用
												     il.Callvirt(ManualCodecMethods.CalculateSize(type));//调用IManualCodec<type>.CalculateSize方法，实际就是call名为CalculateSize的MethodInfo


			    //// CreateConstructor \\\\：

			    foreach (var manualCodecField in classContext.Fields.GetAllManualCodecFields())
            	{
                	var type = manualCodecField.FieldType.GenericTypeArguments[0];
                	ValidateManualCodecType(type);

                	//如下四行相当于:(比如:type为int)IManualCodec<int> codecFor_int_number = this.CodecContainer.GetManualCodecFor<int>(); ok! 具体请参考CodecContainer.GetManualCodecFor方法即可

                	il.Ldarg(thisArgIndex);
                	il.Ldarg(codecContainerArgIndex);
                	il.Call(CodecContainerMethods.GetManualCodecFor(type));
                	il.Stfld(manualCodecField);
            	}

2014-12-15
            	【DynamicMethod + delegate模式】，无需创建Module,Type的方式，直接创建Emit方法的简洁模式，适用于短小代码，但凡是Emit，效率直逼直接调用版

            	sample:

            	delegate int AddDelegate(int a,int b);

            	AddDelegate add_delegate;

            	DynamicMethod addMethod = new DynamicMethod("add_method",typeof(int),new Type[]{typeof(int),typeof(int)});

            	ILGenerator il = addMethod.GetILGenerator();

            	....il Emit code here...

            	il.Ret();

            	//dynamicMethod + delegate模式的应用场景

            	add_delegate = (AddDelegate)addMethod.CreateDelegate(typeof(AddDelegate));

            	int result = add_delegate(1,2);


            	【从IEmittingContext开始...】
            	IEmittingContext：定义了三个属性：MyILGenerator,字节指针DataPointerVar，字节计数变量RemainingBytesVar ； 两个方法：GetSharedVariable获取共享本地变量LocalBuilder和最最关键的注入方法体逻辑的 EmitLoadManualCodecFor(Type type);
            	   |
            	   | -> public abstract class EmittingContextBase : IEmittingContext ，实例化三个属性，实现GetSharedVariable方法，仅将EmitLoadManualCodecFor设为abstract供子类实现
            	   |                              |
            	   |                              | -> 客户端的 ProxyMethodEmittingContext ： 实现EmitLoadManualCodecFor方法只是为每个方法参数声明一个IManualCodec<T>的变量存于ProxyClassFieldCache中
            	   |                              | -> 服务端的 HandlerMethodEmittingContext：实现EmitLoadManualCodecFor方法基本完全等同于ProxyMethodEmittingContext
            	   |                              | -> 真正核心处理的 ManualCodecEmittingContext : 实现EmitLoadManualCodecFor方法内部调用codecContainer.GetManualCodecFor(Type type)为每种类型type生成Emit的处理逻辑，实际就是提取参数值保存到DataPointerVar指向的字节数组


            	明天开始分析服务端逻辑，本周搞定大体框架，下周开始复制Codec的部分核心代码。

            	我初步理解的思路：服务器接收到的字节数组会经过特殊处理后还原为具体参数，然后交由真正的服务接口处理后，再将返回参数打包到字节数组返回，这个完整流程必须搞清除了，才好开始复制





				

                




