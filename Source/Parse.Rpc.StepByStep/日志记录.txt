2014-12-09

15:39 完成Topology的相关功能：读取rpc服务配置，rpc服务配置支持SingleHost[单个端口]和Random[多个端口，随机取一个]的服务配置。
	  ServiceEndPoint格式：tcp://10.9.60.61:8080 or tcp://domain_name:9090
	  rpc配置文件中固定每行的格式为：ServiceName TopologyType(single or random) tcp://domain_name:9090,tcp://domain_name:9191

2014-12-10

	  MethodDescriptionBuilder是根据反射Type提取MethodInfo动态创建方法的核心！

	  MethodDescription [由MethodRemotingType enum,MethodParameterWay enum,MethodParameterDescription,GenericParameterDescription支撑其方法描述功能，用于生成相关方法]

	  今天搞定了ServiceDescriptionBuilder，可以完整获取一个接口的描述信息用于后续的动态生成dynamic assembly!

tip：Linq的Select是专门针对各种集合的每个元素进行【委托方法】的额外处理后返回一个处理后的结果集。

	static void Main()
    {
		// An input data array.
		string[] array = { "cat", "dog", "mouse" };

		// Apply a transformation lambda expression to each element.
		// ... The Select method changes each element in the result.
		var result = array.Select(element => element.ToUpper());

		// Display the result.
		foreach (string value in result)
		{
	    	Console.WriteLine(value);
		}
    }
		
2014-12-11

		开始CodecContainer剖析，基本就是靠TypeBuilder来创建instance和其内部的处理！进入关键部分了...

		还是从ProxyFactory切入：

			1、设定new一个ServiceDescriptionBuilder用以剖析某个接口，亦即ProxyContainer中传入的泛型接口T
			2、设定new一个codecContainer传入最终创建的动态Assembly内进行输入数据的提取？
			3、AppDomain.CurrentDomain来DefineDynamicAssembly->assemblyBuilder.DefineDynamicModule->moduleBuilder.DefineType->TypeBuilder负责fieldCache和classContext的创建

				fieldCache实际就是ProxyClassFieldCache亦即创建几个proxy instance用到的内部字段：methodCallProcessor,scope,timeoutSettings,codecContainer,(manualCodecFields干嘛的还不清楚)
				classContext实际就是通过之前的TypeBuilder创建给DynamicAssembly的module的类型和相关方法以及类型的“构造函数”

				typeBuilder.DefineMethod->methodBuilder.GetILGenerator()->iL

			4、CreateMethod、CreateConstructor
				
				 ProxyMethodParameterCodec：用于动态生成Method参数，重点看如何处理，该类负责为每个参数设定相应的处理引擎(如何提取参数值，如何计算大小，如何转换为二进制数组)

				 ILGenerator is used to generate method bodies for methods and constructors in dynamic assemblies.

				 注意这里强调是"method bodies"，即method和其相关的输入参数在methodBuilder中定义，但方法体中的执行代码采用iL生成。

				 OpCode：struct,用于描述Intermediate Language指令
				 OpCodes：定义了所有的OpCode.
				 ILGenerator.Emit(OpCode,...):将设定的指令OpCode和相关的...其他参数写入dynamic assemblies的IL流中。

				 EmitCalculateSize计算获取每个输入参数的字节大小
				 然后，再根据该大小初始化一个大的字节数组
				 EmitEncode,将各个参数转化为相应的字节数据写入该数组(如果序列化应该是在此引入序列化引擎或者计算输入参数前)

2014-12-12

		如果有时间，重点剖析ProxyFactory的CreateMethod方法中如何生成处理输入参数的执行代码
			ProxyMethodEmittingContext

		下周继续吧，今儿就先这样吧，唉...

		不再纠缠方法类型支持了，一律采用"byte[] methodname(byte[] input)"，只是在其外封装一层T methodnamewrapper(T1);即可。
		后续尽快模拟相关代码其余架构，不再纠结Emit处理引用类型的问题了。继续...本周必须搞定嵌入tcp通讯架构即可。

2014-12-16

				之前的methodBuilder定义了创建方法的名称，参数、返回参数类型等外壳信息，然后从methodBuilder的ILGenerator开始
				真正设定方法的执行代码逻辑，即如下中的il...

		        //用于封装传给远端服务器的请求参数，统一打包到byte[]中。
		        var requestDataArrayVar = il.DeclareLocal(typeof(byte[]));                      // byte[] dataArray

		        bool haveSizeOnStack = false;
                foreach (var codec in genericTypeParameterCodecs)
                {
                    codec.EmitCalculateSize(emittingContext);                               // stack_0 += CalculateSize(T_i)
                    EmitAddIf(il, ref haveSizeOnStack);
                }

                foreach (var parameter in requestParametersCodecs)
                {
                    parameter.EmitCalculateSize(emittingContext);                           // stack_0 += CalculateSize(arg_i)    
                    EmitAddIf(il, ref haveSizeOnStack);
                }

                //stack_0参数是byte大小的确定依据，是否代表了具体的参数具体数据大小已定？
                //data = dataPointer实际是将新创建的byte[]赋予emittingContext的DataPointer供后续写入真实参数数据
                //所以关键的两个foreach codec才是真正如何编码或者要额外可能序列化地方，唉...
                il.Newarr(typeof(byte));                                                    // dataArray = new byte[stack_0]
                il.Stloc(requestDataArrayVar);
                var pinnedVar = il.PinArray(typeof(byte), requestDataArrayVar);             // var pinned dataPointer = pin(dataArray)
                il.Ldloc(pinnedVar);                                                        // data = dataPointer
                il.Stloc(emittingContext.DataPointerVar);


                //最最关键的两行EmitEncode!!!!!!
                //EmitEncode是关键吗？这里的codec目前看来都是Proxy用的IndirectCodec.cs
                foreach (var codec in genericTypeParameterCodecs)
                    codec.EmitEncode(emittingContext);                                      // Encode(T_i, data)

                foreach (var codec in requestParametersCodecs)
                    codec.EmitEncode(emittingContext); 


                *********EmitCalculateSize*********
				根据type载入相应的ManualCodec,然后提取参数值？然后再用ManualCodecMethods.CalculateSize计算具体的数据大小
				这个是明天要搞定的关键点！即ManualCodec相关的代码！

				ProxyMethodEmittingContext->ProxyClassFieldCache->GetOrCreateManualCodec->typeBuilder.DefineType[typeof(IManualCodec<>).MakeGenericType(type)]从而获取ManualCode类型！

				ProxyMethodParameterCodec的Action<MyILGenerator>设定了提取当前方法参数值的方式!自测Ldarg_0和Ldobj【Ldobj貌似是只针对ref out标明的值类型参数拷贝到堆栈上，而引用类型参数呢？】，分别提取ref,out和其他方式的对象参数的值。

2014-12-18

				实现了个简单版的Emit，有助于后续理解相关的Proxy编写

				public interface IComplexEx{
			
					string GetStudent (Student st);
				}

				[Serializable]
				public class Student{

					public string Name{ get; set;}
					public int Age{ get; set;}
					public string Address{ get; set;}
					public bool Male{ get; set;}

					public override string ToString ()
					{
						return string.Format ("[Student: Name={0}, Age={1}, Address={2}, Male={3}]", Name, Age, Address, Male);
					}
				}

				private static void CreateClassForComplex(TypeBuilder typeBuilder){


						Type objType = Type.GetType("System.Object");
						ConstructorInfo objCtor = objType.GetConstructor(new Type[0]);

						var constructorBuilder = typeBuilder.DefineConstructor(
						MethodAttributes.Public, CallingConventions.Standard,new Type[0]);

						ILGenerator ilOfCtor = constructorBuilder.GetILGenerator();

						ilOfCtor.Emit(OpCodes.Ldarg_0);//this，当前实例引用，一般instance的类，ldarg_0就是this
						ilOfCtor.Emit(OpCodes.Call, objCtor);
						ilOfCtor.Emit (OpCodes.Ret);

						typeBuilder.AddInterfaceImplementation (typeof(IComplexEx));//必须加上这句才能代表实现相关接口...
						var methodInfo = typeof(Student).GetMethod ("ToString");
						var methodBuilder = typeBuilder.DefineMethod ("GetStudent", MethodAttributes.Public | MethodAttributes.Final | MethodAttributes.HideBySig |
											MethodAttributes.NewSlot | MethodAttributes.Virtual, CallingConventions.ExplicitThis | CallingConventions.HasThis,typeof(string), new Type[]{ typeof(Student) });

						ILGenerator ilOfmethod = methodBuilder.GetILGenerator ();

						ilOfmethod.Emit (OpCodes.Ldarg_1);//提取Student参数入栈
						ilOfmethod.Emit (OpCodes.Callvirt, methodInfo);//调用Student.ToString()并将结果入栈
						ilOfmethod.Emit (OpCodes.Ret);//返回栈中结果值

				}

				[Test]
				public void TestLdarg(){
		
					var appDomain = AppDomain.CurrentDomain;
					var assemblyBuilder = appDomain.DefineDynamicAssembly(new AssemblyName("rkProxies"), AssemblyBuilderAccess.RunAndSave);
					var moduleBuilder = assemblyBuilder.DefineDynamicModule("rkProxiesModule","rkProxies.dll");
					var typeBuilder = moduleBuilder.DefineType ("rkComplex", TypeAttributes.Public | TypeAttributes.Sealed | TypeAttributes.Class, typeof(object), new Type[]{typeof(IComplexEx)});

					//定义类及其相关类方法
					CreateClassForComplex (typeBuilder);

					try{

						var  type1 = typeBuilder.CreateType ();

						assemblyBuilder.SetEntryPoint(type1.GetMethod("GetStudent"));

						assemblyBuilder.Save("rkProxies.dll");

						Student st = new Student ();

						st.Address="北京";
						st.Age = 30;
						st.Male = false;
						st.Name = "H";

						object instance = Activator.CreateInstance(type1);

						IComplexEx complex = instance as IComplexEx;

						string result = complex.GetStudent(st);


					}catch(Exception e){

						string msg = e.Message;
					}
																								
					Assert.AreEqual (1, 1);
				}
2014-12-19

				非常好的教程：http://www.codeproject.com/Articles/121568/Dynamic-Type-Using-Reflection-Emit

				每个方法都需要TypeBuilder创建的MethodBuilder中获取ILGenerator来创建具体的方法体逻辑
				对于instance，Ldarg_0固定为this,则任何方法的第一个参数起始值为Ldarg_1
				OpCodes.st...开始的类似set,例如：stfld，设置某个实例字段值
				OpCodes.ld...开始的类似load，例如：ldloc_0，是载入局域变量值;ldfld，载入某个实例字段值

				***********split line***********

				A:创建构造类必须的相关类
					ProxyClassFieldCache：代理类缓存字段，根据Type确定[保存了TypeBuilder，其余的是四个关键的基于接口的字段定义且初始化时并不赋值：methodCallProcessor,scope,timeoutSettings,codecContainer，说白了后续的作用只是提供其“定义的接口类型”用于后续的Emit操作具体的instance]
					ProxyClassBuildingContext：代理类的创建类（TypeBuilder和FieldCache)

				B：针对具体的某个方法的每个参数进行Codec封装
					ProxyMethodParameterCodec：对方法的输入参数进行codec封装处理，都是固定用IndirectCodec，其关键点是后续传入的具体处理类IEmittingContext是何方神圣，目测是ProxyMethodEmittingContext
					ProxyMethodGenericArgumentCodec：对方法的泛型输入参数进行codec封装处理，都是固定用IndirectCodec，其关键点是后续传入的具体处理类IEmittingContext是何方神圣，目测是ProxyMethodEmittingContext

				C：
					ProxyMethodEmittingContext：唯一方法EmitLoadManualCodecFor为某个方法的某个参数类型(每中Type只创建一个cache字段)在ProxyClassFieldCache创建IManualCodec<Type>类型的对应字段codec_typename_randomnum而已，也仅仅是个字段定义！
					而后续的封装类ProxyMethodParameterCodec的EmitCalculateSize方法内部调用IndirectCodec的EmitCalculateSize方法内部最终调用ManualCodecMethods.CalculateSize方法计算参数数据大小，但这个ManualCodecMethods内部返回的是typeof(IManualCodec<>).MakeGenericType(type).GetMethodSmart("CalculateSize");的MethodInfo[GetMethodSmart是个扩展方法]，这个目前完全看不懂！
					后续的Encode,Decode都是这么得到MethodInfo然后调用的，关键是这只是接口定义，具体实现的instance怎么传入？



				再看ProxyFactory之CreateMethod

				就是看不明白CaculateSize,Encode,Decode是如何运作的，其余都过了...

				ProxyMethodParameterCodec.EmitCaculateSize中的emitload就得到了当前方法参数数据的具体大小后续只是继续追加封装类型IManualCodec<Ttype>类型定义的大小！oh yeah！搞定！ 

				IL.Ldarg(0);
                IL.Ldfld(fieldCache.GetOrCreateManualCodec(type));
                上面这个是将this.IManualCodec<Type>创建出来并Push入栈

                il => il.Ldarg(index);
                这个是将具体的type参数值Push入栈作为CaculateSize的输入参数待用

                //这里只是调用MethodInfo，当然只要一个简单的方法定义即可，亦即简单的：typeof(SomeType).GetMethod(methodName);
                //关键是真正的实例是通过ICodecContainer的instance传入并实现真正的调用。
                il.Callvirt(ManualCodecMethods.CaculateSize(type));

                这个是调用this.IManualCodec<Type>_Instance.CaculateSize(T Value)方法了，现在关键是看这个instance of IManual<Codec>是通过CodecContainer何时传入

                ManualCodecMethods.CalculateSize是如何运作的是下周的研究点,涉及ManualCodec,ManualCodecBase




