
结合www.dotnetperls.com分析相关源码

2014-12-04：

目的：搞清楚客户端调用到发送的内部机制！

ProxyFactory：动态创建T类型的dynamic assembly，只能run不能保存

               CreateProxyClass中创建的T 在其构造函数中创建了相关的远程请求接口实例，而该请求接口OutgoingRequestProcesser对应的instance何时传入需要继续看代码

			   return (p, s, t) => (T) Activator.CreateInstance(proxyClass, p, s, t, codecContainer);

			   用p,s,t,codeContainer构造函数构造类型T的instance,p:requestProcesser;s:scope[method];t:timeOutSetting;codecContainer:代码解码器

			   而这个T的构造函数在Proxy的CreateProxyClass->CreateConstructor中动态创建出来了

			   亦即：CreateProxyClass创建出T类型的dynamic dll，然后再实例化出相应的instance返回给客户端使用。


ProxyContainer：绑定OutgoingRequestProcesser和proxyFactory实例来动态创建T类型的proxy instance。

IOutgoingRequestProcessor：只是设定了发送数据到远程的接口，但接口中关键的输入参数byte[]中的数据如何进行序列化等格式化操作打包这一块目前看不到入口点。
			   			   目前byte[]数据如何形成，只能寄希望于codecContainer了，否则，对于复杂类型参数如何序列化将是个问题
              

说明：今天确定了该框架不支持复杂类型的传送，那么只能自己再调用此框架前提前序列化并固定采用byte[]参数类型，但目前该框架在多线程模式下测试未通过，待明天继续跟踪确定原因。

2014-12-05：

目的：确认该rpc框架的多线程模式下异常的原因！进而在下周考虑用tcp替代目前的http通讯机制即可。

      经测试，开启多线程模式的运行场景是，在远程调用加锁的情况下还是需要等待所有的远程调用都结束了，貌似才真正发起请求，这尼玛完全不科学啊...得查相关源码，但在多进程情况下貌似没问题！
	  通过ThreadStart启动线程是没问题的，但内存开销不可控，但是采用ThreadPool or Task则彻底废了，再查其实现的客户端请求引擎，已经是采用异步方式了，那么没必要再多此一举，直接认为所有的循环就是开了线程了。
	  但同样对于客户端而言，这个异步只是可以控制超时，客户端调用还是同步方式，必须自行写个引擎来解决这事或者测试在IIS下是否有问题，貌似应该没问题才对！

	  ThreadPool.QueueUserWorkItem(new WaitCallback(UserRunFunction),ParamObject);

	  写完这句，即将用户的带object类型参数ParamObject的方法UserRunFunction(object)置入了UserWorkItem队列，一旦线程池有空闲线程，会自动通过回调WaitCallback实例来执行用户的方法。

	  yield return T 返回IEnumerable<T>集合中一个元素，多次在循环中调用yield return则返回一个完整的IEnumerable<T>集合。

	  public static System.Collections.Generic.IEnumerable<int> Power(int number, int exponent)
      {
        int result = 1;

        for (int i = 0; i < exponent; i++)
        {
            result = result * number;
            yield return result; //相当于返回一个result集合
        }
      }

      public class Galaxies
      {

        public System.Collections.Generic.IEnumerable<Galaxy> NextGalaxy
        {
            get
            {
                yield return new Galaxy { Name = "Tadpole", MegaLightYears = 400 }; //效果同上yield return T instance
                yield return new Galaxy { Name = "Pinwheel", MegaLightYears = 25 };
                yield return new Galaxy { Name = "Milky Way", MegaLightYears = 0 };
                yield return new Galaxy { Name = "Andromeda", MegaLightYears = 3 };
            }
        }

      }

2014-12-08：

目的：准备排查TreadPool或Task不成功的深层次原因。细细研究一下相关的async/await的使用

      NUnit应该好好启用起来，以后的测试不再写什么单独的测试工具，至少自己的项目是这样，一律采用NUnit方式！
      Nunit组件定义了N多的Assert，且提供图形化展示界面，还有比这更靠谱的测试吗？
      NSubstitute组件则能很方便的实现一些接口对象提前进行相关假想场景测试。

      TDD：第一步一定是写一个相关测试并确保其失败！，然后才是为该测试写相关代码然后再测试，直至其测试通过，然后再继续下一个单元测试编写，然后继续迭代这个过程...
     
2014-12-09 to 2014-12-19   

目的：完全逐步复制，如何创建ProxyClass并提取相关输入参数后传入发送请求模块的方方面面即可。通过TDD模式进行复制